### 1. 僵尸进程产生原因
 子进程调用exit()后，并未实际退出，而是留下一个僵尸进程的数据结构，保存在进程的退出码、cpu使用时间等相关信息会保存在进程表中，等待父进程读取。  

  每个Unix进程在进程表里都有一个进入点（entry），核心进程执行该进程时使用到的一切信息都存储在进入点。当用 ps 命令察看系统中的进程信息时，看到的就是进程表中的相关数据。当以fork()系统调用建立一个新的进程后，核心进程就会在进程表中给这个新进程分配一个进入点，然后将相关信息存储在该进入点所对应的进程表内。这些信息中有一项是其父进程的识别码。  

  子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。那么会不会因为父进程太忙来不及 wait 子进程，或者说不知道子进程什么时候结束，而丢失子进程结束时的状态信息呢？  

  不会。因为UNIX提供了一种机制可以保证，只要父进程想知道子进程结束时的状态信息，就可以得到。这种机制就是：当子进程走完了自己的生命周期后，它会执行exit()系统调用，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号the process ID，退出码exit code，退出状态the terminationstatus of the process，运行时间the amount of CPU time taken by the process等），这些数据会一直保留到系统将它传递给它的父进程为止，直到父进程通过wait / waitpid来取时才释放。

### 2. 解决办法
 + 重启  

 + 杀死父进程，让其过继给init，由init进行回收。
``` shell
 ps -ef | grep defunct
```

### 3. 孤儿进程  

  父进程退出，子进程还在运行，会过继给init。


